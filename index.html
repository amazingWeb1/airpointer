<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>AirPointer — Proxy + Track + Vertical Rate</title>
<style>
  :root {
    --bg: #0b0f14;
    --fg: #e6f0ff;
    --muted: #90a4c0;
    --accent: #70b8ff;
    --ok: #66ff9a;
    --warn: #FFC66D;
    --err: #FF7A7A;
  }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; touch-action: manipulation; }
  .wrap { display:flex; flex-direction:column; height:100%; }
  header { padding:12px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  h1 { font-size:16px; margin:0; font-weight:600; letter-spacing:.2px; }
  #startBtn { appearance:none; border:0; border-radius:10px; padding:10px 14px;
    background:linear-gradient(180deg,#1b2a3d,#142030); color:var(--fg); font-weight:600;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 20px rgba(0,0,0,.3); }
  #startBtn:active { transform: translateY(1px); }

  .hud{ padding:8px 16px 0; display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:12px; color:var(--muted);}
  .panel{ background:linear-gradient(180deg,#0d141c,#0a1119); border:1px solid #142130; border-radius:12px; padding:10px;}
  .panel b{ color:var(--fg); }
  .status{ padding:10px 16px 0; color:var(--muted); font-size:12px; min-height:1.4em; }

  .stage{ position:relative; flex:1; margin:12px 16px 16px; border-radius:16px; overflow:hidden;
    background: radial-gradient(120% 100% at 50% 0%, #102030, #070b11 70%); border:1px solid #141F2C;
    perspective:1200px; display:flex; align-items:center; justify-content:center; }
  .stars{ position:absolute; inset:0; background:
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.35), transparent 50%),
      radial-gradient(1.5px 1.5px at 60% 70%, rgba(255,255,255,.25), transparent 50%),
      radial-gradient(1.2px 1.2px at 80% 20%, rgba(255,255,255,.2), transparent 50%),
      radial-gradient(2px 2px at 40% 80%, rgba(255,255,255,.25), transparent 50%);
    opacity:.25; pointer-events:none; }

  /* Compass ring */
  .ring{ position:absolute; width:min(78vmin,78vmax); height:min(78vmin,78vmax);
    border-radius:50%; border:1px solid #1B2B40; box-shadow: inset 0 0 60px rgba(112,184,255,.08);
    display:flex; align-items:center; justify-content:center; }
  .ticks{ position:absolute; inset:0; border-radius:50%;
    mask: radial-gradient(closest-side, rgba(0,0,0,1) calc(50% - 1px), transparent calc(50% + 1px)); }
  .ticks::before{ content:""; position:absolute; inset:0; border-radius:50%;
    background: conic-gradient(from 0deg, rgba(112,184,255,.55) 0deg 1deg, transparent 1deg 30deg);
    filter: drop-shadow(0 0 4px rgba(112,184,255,.4)); }

  /* Track marker on ring (plane's ground track) */
  .track-marker{ position:absolute; width:2px; height:calc(50% - 6px); top:6px; left:50%;
    background: var(--warn); transform-origin: bottom center; border-radius:2px; box-shadow:0 0 8px rgba(255,198,109,.7); }

  .arrow{ position:relative; width:0; height:0; transform-style:preserve-3d; will-change:transform, filter; }
  .arrow-body{ position:absolute; left:-6px; top:-140px; width:12px; height:180px; border-radius:6px;
    background: linear-gradient(90deg,#79C0FF,#2A78C6);
    box-shadow: 0 0 22px rgba(112,184,255,.25), inset 0 -30px 60px rgba(0,0,0,.25), inset 0 0 2px rgba(255,255,255,.4); }
  .arrow-tip{ position:absolute; top:-178px; left:-18px; width:36px; height:36px;
    background: linear-gradient(180deg,#9AD1FF,#438FD8);
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%); filter: drop-shadow(0 0 16px rgba(112,184,255,.4)); }
  .arrow-glow{ position:absolute; left:-60px; top:-230px; width:120px; height:120px; border-radius:50%;
    background: radial-gradient(circle at 50% 40%, rgba(112,184,255,.25), transparent 60%); filter: blur(4px); }
  .center-dot{ position:absolute; width:8px; height:8px; border-radius:50%; background:var(--accent); box-shadow:0 0 8px rgba(112,184,255,.8); }

  /* Distance at tip */
  .tip-label{ position:absolute; top:-210px; left:50%; transform: translateX(-50%);
    padding:4px 8px; border-radius:8px; font-size:12px; white-space:nowrap;
    background: rgba(10,22,34,.85); border:1px solid #15314a; color:var(--fg); }

  .readout{ position:absolute; bottom:14px; left:14px; right:14px; display:flex; flex-wrap:wrap; gap:8px; }
  .pill{ padding:8px 10px; border-radius:10px; font-size:12px; background:linear-gradient(180deg,#0f1a26,#0b151f); border:1px solid #142131; color:var(--fg); }
  .pill.muted{ color:var(--muted); }
  .pill.ok{ color:var(--ok); border-color:#1f3a2a; }
  .pill.warn{ color:var(--warn); border-color:#3a2f1f; }

  /* Lock (elevation match) */
  .locked .arrow-body{ background: linear-gradient(90deg,#9CFFC1,#29C86F); }
  .locked .arrow-tip{ background: linear-gradient(180deg,#B9FFD3,#29C86F); filter: drop-shadow(0 0 18px rgba(102,255,154,.6)); }
  .locked .center-dot{ background:var(--ok); box-shadow:0 0 10px rgba(102,255,154,.9); }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>AirPointer — Bearing, Elev Lock, Track & VRate</h1>
    <button id="startBtn">Start</button>
  </header>

  <div class="hud">
    <div class="panel"><div>GPS: <b id="gpsStatus">idle</b></div><div>Lat/Lon: <b id="latlon">—</b></div></div>
    <div class="panel"><div>Compass: <b id="compassStatus">idle</b></div><div>Heading: <b id="heading">—</b></div></div>
  </div>
  <div class="status" id="status">Tap <b>Start</b> and allow motion + location.</div>

  <div class="stage" id="stage">
    <div class="stars"></div>

    <div class="ring">
      <div class="ticks"></div>
      <!-- plane ground track marker on the ring -->
      <div class="track-marker" id="trackMarker" style="transform: rotate(0deg) translateX(-50%);"></div>
    </div>

    <div class="arrow" id="arrow" aria-hidden="true">
      <div class="arrow-glow"></div>
      <div class="arrow-body"></div>
      <div class="arrow-tip"></div>
      <div class="tip-label" id="tipNM">— NM</div>
    </div>

    <div class="center-dot"></div>

    <div class="readout">
      <div class="pill" id="targetCallsign">Callsign: —</div>
      <div class="pill muted" id="targetDist">Ground: —</div>
      <div class="pill muted" id="targetAlt">Alt: —</div>
      <div class="pill muted" id="targetBrg">Bearing: —</div>
      <div class="pill muted" id="targetEl">Elev: —</div>
      <div class="pill" id="lockState">Lock: —</div>
      <div class="pill" id="trackReadout">Track: —</div>
      <div class="pill" id="motionRel">Relative: —</div>
      <div class="pill" id="vRate">VRate: —</div>
      <div class="pill" id="updateAge">Updated: —</div>
    </div>
  </div>

  <div class="footer" style="padding:10px 16px 16px; font-size:11px; color:var(--muted);">
    Uses proxy path <code>/api/opensky</code>. Add to Home Screen for full-screen.
  </div>
</div>

<script>
(() => {
  const els = {
    startBtn: document.getElementById('startBtn'),
    status: document.getElementById('status'),
    gpsStatus: document.getElementById('gpsStatus'),
    latlon: document.getElementById('latlon'),
    compassStatus: document.getElementById('compassStatus'),
    heading: document.getElementById('heading'),
    arrow: document.getElementById('arrow'),
    stage: document.getElementById('stage'),
    tipNM: document.getElementById('tipNM'),
    trackMarker: document.getElementById('trackMarker'),
    targetCallsign: document.getElementById('targetCallsign'),
    targetDist: document.getElementById('targetDist'),
    targetAlt: document.getElementById('targetAlt'),
    targetBrg: document.getElementById('targetBrg'),
    targetEl: document.getElementById('targetEl'),
    lockState: document.getElementById('lockState'),
    trackReadout: document.getElementById('trackReadout'),
    motionRel: document.getElementById('motionRel'),
    vRate: document.getElementById('vRate'),
    updateAge: document.getElementById('updateAge'),
  };

  // --- Config ---
  const ELEV_LOCK_TOL_DEG = 2.0;     // elevation alignment window
  const SMOOTH_ALPHA = 0.15;         // smoothing for sensors
  const SEARCH_BOX_DEG = 0.4;        // bbox half-size for proxy
  const POLL_BASE_MS = 12000;        // base polling
  let failCount = 0;

  // --- State ---
  let myPos = null;
  let myHeadingTrue = null;
  let myPitch = 0;
  let emaHeading = null, emaPitch = 0;
  let lastPlane = null;
  let fetchTimer = null;

  // --- Utils ---
  const deg2rad = d => d*Math.PI/180;
  const rad2deg = r => r*180/Math.PI;
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const norm360 = h => ((h % 360) + 360) % 360;
  const nmFromMeters = m => m/1852;
  const feetFromMeters = m => m * 3.28084;

  function shortAngleDiff(a, b) {
    let d = norm360(a) - norm360(b);
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
  }
  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const dLat = deg2rad(lat2-lat1), dLon = deg2rad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  function initialBearing(lat1, lon1, lat2, lon2) {
    const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2), Δλ = deg2rad(lon2-lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    return norm360(rad2deg(Math.atan2(y, x)));
  }
  function elevationAngle(distGround_m, altDiff_m) {
    return rad2deg(Math.atan2(altDiff_m, distGround_m));
  }
  function fmtDist(m) {
    if (m < 1000) return `${m.toFixed(0)} m`;
    const km = m/1000; return km < 10 ? `${km.toFixed(2)} km` : `${km.toFixed(1)} km`;
  }

  function setStatus(msg, tone="") {
    els.status.textContent = msg;
    els.status.style.color = tone==="err" ? "var(--err)" : tone==="warn" ? "var(--warn)" : "var(--muted)";
  }

  // --- Sensors ---
  async function enableOrientation() {
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") throw new Error("Motion permission denied");
      }
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      els.compassStatus.textContent = "ok";
    } catch (e) {
      els.compassStatus.textContent = "blocked";
      setStatus("Compass/motion permission denied or unsupported.", "warn");
    }
  }
  function onDeviceOrientation(e) {
    let heading;
    if (typeof e.webkitCompassHeading === 'number') {
      heading = e.webkitCompassHeading; // iOS true-ish north, 0..360 CW
    } else if (typeof e.alpha === 'number') {
      heading = 360 - e.alpha;
    }
    if (typeof heading === 'number' && !Number.isNaN(heading)) {
      if (emaHeading == null) emaHeading = heading;
      const diff = shortAngleDiff(heading, emaHeading);
      emaHeading = norm360(emaHeading + SMOOTH_ALPHA * diff);
      myHeadingTrue = emaHeading;
      els.heading.textContent = `${myHeadingTrue.toFixed(0)}°`;
    }
    if (typeof e.beta === 'number') {
      const p = clamp(e.beta, -90, 90);
      emaPitch = emaPitch + SMOOTH_ALPHA * (p - emaPitch);
      myPitch = emaPitch;
    }
    updateArrowTransform();
  }
  function enableGeo() {
    if (!navigator.geolocation) {
      els.gpsStatus.textContent = "unsupported";
      setStatus("Geolocation unsupported.", "err");
      return;
    }
    els.gpsStatus.textContent = "requesting…";
    navigator.geolocation.watchPosition(pos => {
      myPos = { lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy };
      els.gpsStatus.textContent = "ok";
      els.latlon.textContent = `${myPos.lat.toFixed(5)}, ${myPos.lon.toFixed(5)}`;
      scheduleFetch(200);
    }, err => {
      els.gpsStatus.textContent = "error";
      setStatus(`GPS error: ${err.message}`, "err");
    }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 15000 });
  }

  // --- Fetch via proxy (/api/opensky) ---
  function scheduleFetch(ms=POLL_BASE_MS) {
    clearTimeout(fetchTimer);
    const jitter = Math.floor(Math.random() * 1500);
    fetchTimer = setTimeout(fetchNearestPlane, ms + jitter);
  }

  async function fetchNearestPlane() {
    if (!myPos) return scheduleFetch(2000);
    const url = `/api/opensky?lat=${myPos.lat}&lon=${myPos.lon}&d=${SEARCH_BOX_DEG}`;
    try {
      setStatus("Fetching aircraft…");
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      const states = Array.isArray(data.states) ? data.states : [];

      /* OpenSky state fields (index):
         0: icao24, 1: callsign, 2: origin_country, 3: time_position, 4: last_contact,
         5: lon, 6: lat, 7: baro_alt (m), 8: on_ground, 9: velocity (m/s),
         10: true_track (deg), 11: vertical_rate (m/s), 12: sensors,
         13: geo_alt (m), 14: squawk, 15: spi, 16: position_source
      */
      let best = null;
      for (const s of states) {
        const callsign = (s[1] || "").trim() || "—";
        const lon = s[5], lat = s[6];
        const geo_alt = s[13]; // meters (may be null)
        const track = s[10];   // degrees (may be null)
        const vRate = s[11];   // m/s (may be null)
        if (lat == null || lon == null) continue;

        const ground_m = haversineMeters(myPos.lat, myPos.lon, lat, lon);
        const alt_m = (geo_alt != null ? geo_alt : 0);
        const dist3d_m = Math.hypot(ground_m, alt_m);

        if (!best || dist3d_m < best.dist3d_m) {
          best = { lat, lon, alt_m, ground_m, dist3d_m, callsign, track, vRate };
        }
      }
      if (!best) {
        setStatus("No aircraft nearby (retrying)…", "warn");
        failCount = Math.min(failCount + 1, 6);
        scheduleFetch(Math.min(POLL_BASE_MS * (2 ** failCount), 120000));
        return;
      }

      const brg = initialBearing(myPos.lat, myPos.lon, best.lat, best.lon);
      const el  = elevationAngle(best.ground_m, best.alt_m);

      // Relative motion analysis
      const brgPlaneToMe = initialBearing(best.lat, best.lon, myPos.lat, myPos.lon);
      const trackDeg = (typeof best.track === 'number') ? norm360(best.track) : null;
      let relStr = "—";
      if (trackDeg != null) {
        const rel = shortAngleDiff(trackDeg, brgPlaneToMe); // 0=toward you, 180=away
        const a = Math.abs(rel);
        if (a <= 30) relStr = "toward you";
        else if (a >= 150) relStr = "away";
        else relStr = `crossing (${a.toFixed(0)}° to your ${rel >= 0 ? "right" : "left"})`;
      }

      // Vertical rate
      let vStr = "—";
      if (typeof best.vRate === 'number') {
        if (best.vRate > 0.3) vStr = `Climbing (+${(best.vRate*196.8504).toFixed(0)} fpm)`;
        else if (best.vRate < -0.3) vStr = `Descending (${(best.vRate*196.8504).toFixed(0)} fpm)`;
        else vStr = "Level";
      }

      lastPlane = {
        ...best,
        brg, el,
        trackDeg,
        relStr,
        vStr,
        time: (data.time || Date.now()/1000)
      };

      updateTargetReadout();
      updateArrowTransform();
      setStatus("Tracking nearest aircraft.");
      failCount = 0;
    } catch (e) {
      failCount = Math.min(failCount + 1, 6);
      setStatus("Aircraft fetch failed (proxy/upstream). Retrying…", "warn");
    } finally {
      const backoff = Math.min(POLL_BASE_MS * (2 ** failCount), 120000);
      scheduleFetch(backoff);
    }
  }

  // --- UI updates ---
  function updateTargetReadout() {
    if (!lastPlane) return;
    const nm = nmFromMeters(lastPlane.dist3d_m);
    const alt_ft = feetFromMeters(lastPlane.alt_m);
    els.targetCallsign.textContent = `Callsign: ${lastPlane.callsign}`;
    els.targetDist.textContent = `Ground: ${fmtDist(lastPlane.ground_m)}`;
    els.targetAlt.textContent = `Alt: ${Math.round(alt_ft).toLocaleString()} ft`;
    els.targetBrg.textContent = `Bearing: ${lastPlane.brg.toFixed(0)}°`;
    els.targetEl.textContent  = `Elev: ${lastPlane.el.toFixed(1)}°`;
    els.tipNM.textContent     = `${nm.toFixed(2)} NM`;

    if (lastPlane.trackDeg != null) {
      els.trackReadout.textContent = `Track: ${lastPlane.trackDeg.toFixed(0)}°`;
      // rotate marker: 0° (north/up) corresponds to no rotation; we rotate CW for degrees
      els.trackMarker.style.transform = `rotate(${lastPlane.trackDeg}deg) translateX(-50%)`;
      els.trackMarker.style.display = "";
    } else {
      els.trackReadout.textContent = "Track: —";
      els.trackMarker.style.display = "none";
    }

    els.motionRel.textContent = `Relative: ${lastPlane.relStr}`;
    els.vRate.textContent = `VRate: ${lastPlane.vStr}`;

    const ageSec = Math.max(0, Math.round(Date.now()/1000 - (lastPlane.time||Date.now()/1000)));
    els.updateAge.textContent = `Updated: ${ageSec}s ago`;
  }

  function updateArrowTransform() {
    if (!lastPlane || myHeadingTrue == null) return;

    const yawDiff = shortAngleDiff(lastPlane.brg, myHeadingTrue); // +CW relative to your facing
    const pitchDiff = clamp(lastPlane.el - myPitch, -90, 90);

    const transform = `rotateZ(${yawDiff}deg) rotateX(${-pitchDiff}deg) translateZ(0)`;
    els.arrow.style.transform = transform;

    const elevAligned = Math.abs(pitchDiff) <= ELEV_LOCK_TOL_DEG;
    els.stage.classList.toggle('locked', elevAligned);
    els.lockState.textContent = elevAligned
      ? `Lock: ELEV OK (±${ELEV_LOCK_TOL_DEG}°)`
      : `Lock: — (Δ${pitchDiff.toFixed(1)}°)`;

    const misalign = Math.hypot(yawDiff, pitchDiff);
    const intensity = Math.max(0, Math.min(1, 1 - misalign/45));
    els.arrow.style.filter = `drop-shadow(0 0 ${8 + 24*intensity}px rgba(112,184,255,${0.25+0.45*intensity}))`;
  }

  // --- Start ---
  els.startBtn.addEventListener('click', async () => {
    els.startBtn.disabled = true;
    setStatus("Requesting motion + location permissions…");
    await enableOrientation();
    enableGeo();
    scheduleFetch(1000);

    if ('wakeLock' in navigator) { try { await navigator.wakeLock.request('screen'); } catch {} }
    setStatus("Initializing sensors…");
  });

  document.addEventListener('visibilitychange', () => { if (!document.hidden) scheduleFetch(1000); });
})();
</script>
</body>
</html>
