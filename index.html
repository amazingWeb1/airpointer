<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>AirPointer — Bearing + Elevation Lock</title>
<style>
  :root {
    --bg: #0b0f14;
    --fg: #e6f0ff;
    --muted: #90a4c0;
    --accent: #70b8ff;
    --ok: #66ff9a;
    --warn: #FFC66D;
    --err: #FF7A7A;
  }
  html, body {
    margin: 0; height: 100%; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
    touch-action: manipulation;
  }
  .wrap { display:flex; flex-direction:column; height:100%; }
  header { padding: 12px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  h1 { font-size: 16px; margin:0; font-weight:600; letter-spacing:.2px; color: var(--fg); }
  #startBtn {
    appearance:none; border:0; border-radius:10px; padding:10px 14px;
    background: linear-gradient(180deg, #1b2a3d, #142030);
    color: var(--fg); font-weight:600; letter-spacing:.3px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 20px rgba(0,0,0,.3);
  }
  #startBtn:active { transform: translateY(1px); }

  .hud {
    padding:8px 16px 0; display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:12px; color:var(--muted);
  }
  .panel { background: linear-gradient(180deg, #0d141c, #0a1119); border:1px solid #142130; border-radius:12px; padding:10px; }
  .panel b { color: var(--fg); }
  .status { padding: 10px 16px 0; color: var(--muted); font-size:12px; min-height: 1.4em; }

  .stage {
    position:relative; flex:1; margin:12px 16px 16px;
    border-radius:16px; overflow:hidden; background: radial-gradient(120% 100% at 50% 0%, #102030, #070b11 70%);
    border:1px solid #141F2C;
    perspective: 1200px;
    display:flex; align-items:center; justify-content:center;
  }
  .stars {
    position:absolute; inset:0; background:
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.35), transparent 50%),
      radial-gradient(1.5px 1.5px at 60% 70%, rgba(255,255,255,.25), transparent 50%),
      radial-gradient(1.2px 1.2px at 80% 20%, rgba(255,255,255,.2), transparent 50%),
      radial-gradient(2px 2px at 40% 80%, rgba(255,255,255,.25), transparent 50%);
    opacity:.25; pointer-events:none;
  }
  .ring {
    position:absolute; width:min(78vmin, 78vmax); height:min(78vmin, 78vmax);
    border-radius:50%; border:1px solid #1B2B40; box-shadow: inset 0 0 60px rgba(112,184,255,.08);
    display:flex; align-items:center; justify-content:center;
  }
  .ticks { position:absolute; inset:0; border-radius:50%; mask: radial-gradient(closest-side, rgba(0,0,0,1) calc(50% - 1px), transparent calc(50% + 1px)); }
  .ticks::before{
    content:""; position:absolute; inset:0; border-radius:50%;
    background: conic-gradient(from 0deg, rgba(112,184,255,.55) 0deg 1deg, transparent 1deg 30deg);
    filter: drop-shadow(0 0 4px rgba(112,184,255,.4));
  }

  .arrow {
    position:relative; width:0; height:0; transform-style:preserve-3d; will-change:transform, filter;
  }
  .arrow-body {
    position:absolute; left:-6px; top:-140px; width:12px; height:180px; border-radius:6px;
    background: linear-gradient(90deg, #79C0FF, #2A78C6);
    box-shadow:
      0 0 22px rgba(112,184,255,.25),
      inset 0 -30px 60px rgba(0,0,0,.25),
      inset 0 0 2px rgba(255,255,255,.4);
  }
  .arrow-tip {
    position:absolute; top:-178px; left:-18px; width:36px; height:36px;
    background: linear-gradient(180deg, #9AD1FF, #438FD8);
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    filter: drop-shadow(0 0 16px rgba(112,184,255,.4));
  }
  .arrow-glow {
    position:absolute; left:-60px; top:-230px; width:120px; height:120px; border-radius:50%;
    background: radial-gradient(circle at 50% 40%, rgba(112,184,255,.25), transparent 60%);
    filter: blur(4px);
  }
  .center-dot { position:absolute; width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow: 0 0 8px rgba(112,184,255,.8); }

  /* Distance label at the tip */
  .tip-label {
    position:absolute; top:-210px; left:50%; transform: translateX(-50%);
    padding:4px 8px; border-radius:8px; font-size:12px; white-space:nowrap;
    background: rgba(10,22,34,.85); border:1px solid #15314a; color: var(--fg);
  }

  /* Readout */
  .readout { position:absolute; bottom: 14px; left: 14px; right: 14px; display:flex; flex-wrap:wrap; gap:8px; }
  .pill { padding:8px 10px; border-radius:10px; font-size:12px; background: linear-gradient(180deg, #0f1a26, #0b151f); border:1px solid #142131; color: var(--fg); }
  .pill.muted { color: var(--muted); }
  .pill.ok { color: var(--ok); border-color:#1f3a2a; }
  .pill.warn { color: var(--warn); border-color:#3a2f1f; }

  /* "Lock" visual when elevation matches */
  .locked .arrow-body { background: linear-gradient(90deg, #9CFFC1, #29C86F); }
  .locked .arrow-tip  { background: linear-gradient(180deg, #B9FFD3, #29C86F); filter: drop-shadow(0 0 18px rgba(102,255,154,.6)); }
  .locked .center-dot  { background: var(--ok); box-shadow: 0 0 10px rgba(102,255,154,.9); }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>AirPointer — Bearing + Elevation Lock</h1>
    <button id="startBtn">Start</button>
  </header>

  <div class="hud">
    <div class="panel"><div>GPS: <b id="gpsStatus">idle</b></div><div>Lat/Lon: <b id="latlon">—</b></div></div>
    <div class="panel"><div>Compass: <b id="compassStatus">idle</b></div><div>Heading: <b id="heading">—</b></div></div>
  </div>
  <div class="status" id="status">Tap <b>Start</b> and allow motion + location.</div>

  <div class="stage" id="stage">
    <div class="stars"></div>
    <div class="ring"><div class="ticks"></div></div>

    <div class="arrow" id="arrow" aria-hidden="true">
      <div class="arrow-glow"></div>
      <div class="arrow-body"></div>
      <div class="arrow-tip"></div>
      <div class="tip-label" id="tipNM">— NM</div>
    </div>

    <div class="center-dot"></div>

    <div class="readout">
      <div class="pill" id="targetCallsign">Callsign: —</div>
      <div class="pill muted" id="targetDist">Ground: —</div>
      <div class="pill muted" id="targetAlt">Alt: —</div>
      <div class="pill muted" id="targetBrg">Bearing: —</div>
      <div class="pill muted" id="targetEl">Elev: —</div>
      <div class="pill" id="lockState">Lock: —</div>
      <div class="pill" id="updateAge">Updated: —</div>
    </div>
  </div>

  <div class="footer" style="padding:10px 16px 16px; font-size:11px; color:var(--muted);">
    Tip: add to Home Screen for full-screen. Data: OpenSky (public; rate limits apply).
  </div>
</div>

<script>
(() => {
  const els = {
    startBtn: document.getElementById('startBtn'),
    status: document.getElementById('status'),
    gpsStatus: document.getElementById('gpsStatus'),
    latlon: document.getElementById('latlon'),
    compassStatus: document.getElementById('compassStatus'),
    heading: document.getElementById('heading'),
    arrow: document.getElementById('arrow'),
    stage: document.getElementById('stage'),
    tipNM: document.getElementById('tipNM'),
    targetCallsign: document.getElementById('targetCallsign'),
    targetDist: document.getElementById('targetDist'),
    targetAlt: document.getElementById('targetAlt'),
    targetBrg: document.getElementById('targetBrg'),
    targetEl: document.getElementById('targetEl'),
    lockState: document.getElementById('lockState'),
    updateAge: document.getElementById('updateAge'),
  };

  // --- Config ---
  const ELEV_LOCK_TOL_DEG = 2.0; // ±2° window for "turn green" lock
  const SMOOTH_ALPHA = 0.15;     // smoothing factor for sensors
  const SEARCH_BOX_DEG = 0.5;    // initial bbox half-size

  // --- State ---
  let myPos = null;             // {lat, lon}
  let myHeadingTrue = null;     // degrees 0..360 (true-ish)
  let myPitch = 0;              // degrees [-90..90] (front-back tilt)
  let emaHeading = null, emaPitch = 0;
  let lastPlane = null;         // target state object
  let fetchTimer = null;

  // --- Utils ---
  const deg2rad = d => d*Math.PI/180;
  const rad2deg = r => r*180/Math.PI;
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const norm360 = h => ((h % 360) + 360) % 360;
  const nmFromMeters = m => m/1852;
  const feetFromMeters = m => m * 3.28084;

  function shortAngleDiff(a, b) {
    let d = norm360(a) - norm360(b);
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
  }
  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const dLat = deg2rad(lat2-lat1);
    const dLon = deg2rad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 +
              Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  function initialBearing(lat1, lon1, lat2, lon2) {
    const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2);
    const Δλ = deg2rad(lon2-lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    return norm360(rad2deg(Math.atan2(y, x)));
  }
  function elevationAngle(distGround_m, altDiff_m) {
    return rad2deg(Math.atan2(altDiff_m, distGround_m));
  }
  function fmtDist(m) {
    if (m < 1000) return `${m.toFixed(0)} m`;
    const km = m/1000;
    return km < 10 ? `${km.toFixed(2)} km` : `${km.toFixed(1)} km`;
  }

  // --- Permissions / sensors ---
  async function enableOrientation() {
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") throw new Error("Motion permission denied");
      }
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      els.compassStatus.textContent = "ok";
    } catch (e) {
      els.compassStatus.textContent = "blocked";
      setStatus("Compass/motion permission denied or unsupported.", "warn");
    }
  }
  function onDeviceOrientation(e) {
    // Heading
    let heading;
    if (typeof e.webkitCompassHeading === 'number') {
      heading = e.webkitCompassHeading; // iOS: 0=N, CW positive
    } else if (typeof e.alpha === 'number') {
      heading = 360 - e.alpha; // best-effort for Android
    }
    if (typeof heading === 'number' && !Number.isNaN(heading)) {
      if (emaHeading == null) emaHeading = heading;
      const diff = shortAngleDiff(heading, emaHeading);
      emaHeading = norm360(emaHeading + SMOOTH_ALPHA * diff);
      myHeadingTrue = emaHeading;
      els.heading.textContent = `${myHeadingTrue.toFixed(0)}°`;
    }
    // Pitch (front-back tilt)
    if (typeof e.beta === 'number') {
      const p = clamp(e.beta, -90, 90);
      emaPitch = emaPitch + SMOOTH_ALPHA * (p - emaPitch);
      myPitch = emaPitch;
    }
    updateArrowTransform();
  }
  function enableGeo() {
    if (!navigator.geolocation) {
      els.gpsStatus.textContent = "unsupported";
      setStatus("Geolocation unsupported.", "err");
      return;
    }
    els.gpsStatus.textContent = "requesting…";
    navigator.geolocation.watchPosition(pos => {
      myPos = { lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy };
      els.gpsStatus.textContent = "ok";
      els.latlon.textContent = `${myPos.lat.toFixed(5)}, ${myPos.lon.toFixed(5)}`;
      scheduleFetch(200);
    }, err => {
      els.gpsStatus.textContent = "error";
      setStatus(`GPS error: ${err.message}`, "err");
    }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 15000 });
  }

  // --- Fetch planes (OpenSky) ---
  function scheduleFetch(ms=8000){ clearTimeout(fetchTimer); fetchTimer = setTimeout(fetchNearestPlane, ms); }
  async function fetchNearestPlane() {
    if (!myPos) return scheduleFetch(2000);
    const d = SEARCH_BOX_DEG;
    const url = `https://opensky-network.org/api/states/all?lamin=${myPos.lat-d}&lomin=${myPos.lon-d}&lamax=${myPos.lat+d}&lomax=${myPos.lon+d}`;
    try {
      setStatus("Fetching aircraft…");
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      const states = Array.isArray(data.states) ? data.states : [];

      let best = null;
      for (const s of states) {
        const callsign = (s[1] || "").trim() || "—";
        const lon = s[5], lat = s[6];
        const geo_alt = s[13]; // meters (may be null)
        if (lat == null || lon == null) continue;
        const ground_m = haversineMeters(myPos.lat, myPos.lon, lat, lon);
        const alt_m = (geo_alt != null ? geo_alt : 0);
        const dist3d_m = Math.hypot(ground_m, alt_m);
        if (!best || dist3d_m < best.dist3d_m) best = { lat, lon, alt_m, callsign, ground_m, dist3d_m };
      }
      if (!best) {
        setStatus("No aircraft nearby (retrying)…", "warn");
        scheduleFetch(4000);
        return;
      }
      const brg = initialBearing(myPos.lat, myPos.lon, best.lat, best.lon);
      const el  = elevationAngle(best.ground_m, best.alt_m);
      lastPlane = {
        ...best,
        brg, el,
        time: (data.time || Date.now()/1000)
      };
      updateTargetReadout();
      updateArrowTransform();
      setStatus("Tracking nearest aircraft.");
    } catch (e) {
      setStatus("Aircraft fetch failed (rate limit / CORS). Retrying…", "warn");
    } finally {
      scheduleFetch(8000);
    }
  }

  // --- UI updates ---
  function setStatus(msg, tone="") {
    els.status.textContent = msg;
    els.status.style.color =
      tone==="err"? "var(--err)" :
      tone==="warn" ? "var(--warn)" : "var(--muted)";
  }

  function updateTargetReadout() {
    if (!lastPlane) return;
    const nm = nmFromMeters(lastPlane.dist3d_m);
    const alt_ft = feetFromMeters(lastPlane.alt_m);
    els.targetCallsign.textContent = `Callsign: ${lastPlane.callsign}`;
    els.targetDist.textContent = `Ground: ${fmtDist(lastPlane.ground_m)}`;
    els.targetAlt.textContent = `Alt: ${Math.round(alt_ft).toLocaleString()} ft`;
    els.targetBrg.textContent = `Bearing: ${lastPlane.brg.toFixed(0)}°`;
    els.targetEl.textContent  = `Elev: ${lastPlane.el.toFixed(1)}°`;
    els.tipNM.textContent     = `${nm.toFixed(2)} NM`;
    const ageSec = Math.max(0, Math.round(Date.now()/1000 - (lastPlane.time||Date.now()/1000)));
    els.updateAge.textContent = `Updated: ${ageSec}s ago`;
  }

  function updateArrowTransform() {
    if (!lastPlane || myHeadingTrue == null) return;

    // Rotate in azimuth
    const yawDiff = shortAngleDiff(lastPlane.brg, myHeadingTrue); // +CW
    // Elevation lock detection: when your phone's upward tilt equals target elevation
    const pitchDiff = clamp(lastPlane.el - myPitch, -90, 90);

    // Apply rotations to the arrow (visual)
    const transform = `rotateZ(${yawDiff}deg) rotateX(${-pitchDiff}deg) translateZ(0)`;
    els.arrow.style.transform = transform;

    // Lock state (turn green) when elevation aligned within tolerance
    const elevAligned = Math.abs(pitchDiff) <= ELEV_LOCK_TOL_DEG;
    els.stage.classList.toggle('locked', elevAligned);
    els.lockState.textContent = elevAligned
      ? `Lock: ELEV OK (±${ELEV_LOCK_TOL_DEG}°)`
      : `Lock: — (Δ${pitchDiff.toFixed(1)}°)`;

    // Extra glow stronger when aligned in BOTH yaw & pitch (optional feel)
    const misalign = Math.hypot(yawDiff, pitchDiff);
    const intensity = Math.max(0, Math.min(1, 1 - misalign/45));
    els.arrow.style.filter = `drop-shadow(0 0 ${8 + 24*intensity}px rgba(112,184,255,${0.25+0.45*intensity}))`;
  }

  // --- Start ---
  els.startBtn.addEventListener('click', async () => {
    els.startBtn.disabled = true;
    setStatus("Requesting motion + location permissions…");
    await enableOrientation();
    enableGeo();
    scheduleFetch(1000);

    if ('wakeLock' in navigator) { try { await navigator.wakeLock.request('screen'); } catch {} }
    setStatus("Initializing sensors…");
  });

  document.addEventListener('visibilitychange', () => { if (!document.hidden) scheduleFetch(1000); });
})();
</script>
</body>
</html>

