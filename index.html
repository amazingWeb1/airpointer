<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>AirPointer — Nearest Airplane Arrow (Prototype)</title>
<style>
  :root {
    --bg: #0b0f14;
    --fg: #e6f0ff;
    --muted: #90a4c0;
    --accent: #70b8ff;
    --good: #7CFFA3;
    --warn: #FFC66D;
    --err: #FF7A7A;
  }
  html, body {
    margin: 0; height: 100%; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
    touch-action: manipulation;
  }
  .wrap { display:flex; flex-direction:column; height:100%; }
  header { padding: 12px 16px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  h1 { font-size: 16px; margin:0; font-weight:600; letter-spacing:.2px; color: var(--fg); }
  #startBtn {
    appearance:none; border:0; border-radius:10px; padding:10px 14px;
    background: linear-gradient(180deg, #1b2a3d, #142030);
    color: var(--fg); font-weight:600; letter-spacing:.3px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 6px 20px rgba(0,0,0,.3);
  }
  #startBtn:active { transform: translateY(1px); }

  .hud {
    padding:8px 16px 0; display:grid; grid-template-columns:1fr 1fr; gap:8px; font-size:12px; color:var(--muted);
  }
  .hud b { color: var(--fg); }
  .panel { background: linear-gradient(180deg, #0d141c, #0a1119); border:1px solid #142130; border-radius:12px; padding:10px; }
  .status { padding: 10px 16px 0; color: var(--muted); font-size:12px; min-height: 1.4em; }

  /* Arrow stage */
  .stage {
    position:relative; flex:1; margin:12px 16px 16px;
    border-radius:16px; overflow:hidden; background: radial-gradient(120% 100% at 50% 0%, #102030, #070b11 70%);
    border:1px solid #141F2C;
    perspective: 1200px;  /* 3D perspective */
    display:flex; align-items:center; justify-content:center;
  }
  /* Subtle starfield for vibe */
  .stars {
    position:absolute; inset:0; background:
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.35), transparent 50%),
      radial-gradient(1.5px 1.5px at 60% 70%, rgba(255,255,255,.25), transparent 50%),
      radial-gradient(1.2px 1.2px at 80% 20%, rgba(255,255,255,.2), transparent 50%),
      radial-gradient(2px 2px at 40% 80%, rgba(255,255,255,.25), transparent 50%);
    opacity:.25; pointer-events:none;
  }

  /* Compass ring */
  .ring {
    position:absolute; width:min(78vmin, 78vmax); height:min(78vmin, 78vmax);
    border-radius:50%; border:1px solid #1B2B40; box-shadow: inset 0 0 60px rgba(112,184,255,.08);
    display:flex; align-items:center; justify-content:center;
    transform: translateZ(0);
  }
  .ticks {
    position:absolute; inset:0; border-radius:50%;
    mask: radial-gradient(closest-side, rgba(0,0,0,1) calc(50% - 1px), transparent calc(50% + 1px));
  }
  .ticks::before{
    content:""; position:absolute; inset:0; border-radius:50%;
    background:
      conic-gradient(from 0deg, rgba(112,184,255,.55) 0deg 1deg, transparent 1deg 30deg);
    filter: drop-shadow(0 0 4px rgba(112,184,255,.4));
  }

  /* 3D Arrow */
  .arrow {
    position:relative; width: 0; height: 0;
    transform-style: preserve-3d;
    will-change: transform;
  }
  /* Build arrow with pseudo-3D using layered elements */
  .arrow-body {
    position:absolute; left:-6px; top:-140px; width:12px; height:180px; border-radius:6px;
    background: linear-gradient(90deg, #79C0FF, #2A78C6);
    box-shadow:
      0 0 22px rgba(112,184,255,.25),
      inset 0 -30px 60px rgba(0,0,0,.25),
      inset 0 0 2px rgba(255,255,255,.4);
    transform: translateZ(0);
  }
  .arrow-tip {
    position:absolute; top:-178px; left:-18px; width:36px; height:36px;
    background: linear-gradient(180deg, #9AD1FF, #438FD8);
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    filter: drop-shadow(0 0 16px rgba(112,184,255,.4));
  }
  .arrow-glow {
    position:absolute; left:-60px; top:-230px; width:120px; height:120px; border-radius:50%;
    background: radial-gradient(circle at 50% 40%, rgba(112,184,255,.25), transparent 60%);
    filter: blur(4px);
  }

  /* Center aid dot */
  .center-dot {
    position:absolute; width:8px; height:8px; border-radius:50%;
    background: var(--accent); box-shadow: 0 0 8px rgba(112,184,255,.8);
  }

  /* Target info card */
  .readout {
    position:absolute; bottom: 14px; left: 14px; right: 14px;
    display:flex; flex-wrap:wrap; gap:8px;
  }
  .pill {
    padding:8px 10px; border-radius:10px; font-size:12px;
    background: linear-gradient(180deg, #0f1a26, #0b151f);
    border:1px solid #142131; color: var(--fg);
  }
  .pill.muted { color: var(--muted); }
  .pill.good { border-color:#1f3a2a; color: var(--good); }
  .pill.warn { border-color:#3a2f1f; color: var(--warn); }

  .footer {
    padding: 10px 16px 16px; font-size:11px; color:var(--muted);
  }
  a { color: #9CCDFF; text-decoration: none; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>AirPointer — Nearest Airplane</h1>
    <button id="startBtn">Start</button>
  </header>

  <div class="hud">
    <div class="panel"><div>GPS: <b id="gpsStatus">idle</b></div><div>Lat/Lon: <b id="latlon">—</b></div></div>
    <div class="panel"><div>Compass: <b id="compassStatus">idle</b></div><div>Heading: <b id="heading">—</b></div></div>
  </div>
  <div class="status" id="status">Tap <b>Start</b> to grant permissions for motion + location.</div>

  <div class="stage" id="stage">
    <div class="stars"></div>
    <div class="ring"><div class="ticks"></div></div>
    <div class="arrow" id="arrow" aria-hidden="true">
      <div class="arrow-glow"></div>
      <div class="arrow-body"></div>
      <div class="arrow-tip"></div>
    </div>
    <div class="center-dot"></div>

    <div class="readout">
      <div class="pill" id="targetCallsign">Callsign: —</div>
      <div class="pill muted" id="targetDist">Dist: —</div>
      <div class="pill muted" id="targetAlt">Alt: —</div>
      <div class="pill muted" id="targetBrg">Bearing: —</div>
      <div class="pill muted" id="targetEl">Elev: —</div>
      <div class="pill" id="updateAge">Updated: —</div>
    </div>
  </div>

  <div class="footer">
    Prototype tips: needs HTTPS for sensors. iOS Safari requires a tap before motion permission. Data from OpenSky (public, rate-limited).
  </div>
</div>

<script>
(() => {
  const els = {
    startBtn: document.getElementById('startBtn'),
    status: document.getElementById('status'),
    gpsStatus: document.getElementById('gpsStatus'),
    latlon: document.getElementById('latlon'),
    compassStatus: document.getElementById('compassStatus'),
    heading: document.getElementById('heading'),
    arrow: document.getElementById('arrow'),
    targetCallsign: document.getElementById('targetCallsign'),
    targetDist: document.getElementById('targetDist'),
    targetAlt: document.getElementById('targetAlt'),
    targetBrg: document.getElementById('targetBrg'),
    targetEl: document.getElementById('targetEl'),
    updateAge: document.getElementById('updateAge'),
  };

  // State
  let myPos = null; // {lat, lon}
  let myHeadingTrue = null; // degrees (0..360), true north-ish
  let myPitch = 0; // device pitch approx
  let lastPlane = null; // {lat, lon, alt_m, callsign, brg, el, dist_m, time}
  let emaHeading = null; // smoothed heading
  let emaPitch = 0;
  const alpha = 0.15; // smoothing factor

  const deg2rad = d => d*Math.PI/180;
  const rad2deg = r => r*180/Math.PI;
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const norm360 = h => ((h % 360) + 360) % 360;
  const shortAngleDiff = (a, b) => {
    let d = norm360(a) - norm360(b);
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
  };

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const dLat = deg2rad(lat2-lat1);
    const dLon = deg2rad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 +
              Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  function initialBearing(lat1, lon1, lat2, lon2) {
    const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2);
    const Δλ = deg2rad(lon2-lon1);
    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    return norm360(rad2deg(Math.atan2(y, x)));
  }
  function elevationAngle_m(dist_m, altDiff_m) {
    return rad2deg(Math.atan2(altDiff_m, dist_m));
  }
  function formatDist(m) {
    if (m < 1000) return `${m.toFixed(0)} m`;
    const km = m/1000;
    if (km < 10) return `${km.toFixed(2)} km`;
    return `${km.toFixed(1)} km`;
  }
  const metersToFeet = m => m == null ? null : m * 3.28084;

  function setStatus(msg, tone="") {
    els.status.textContent = msg;
    els.status.style.color =
      tone==="err"? "var(--err)" :
      tone==="warn" ? "var(--warn)" : "var(--muted)";
  }

  // Device orientation handling (Android vs iOS)
  async function enableOrientation() {
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") throw new Error("Motion permission denied");
      }
      window.addEventListener('deviceorientation', onDeviceOrientation, true);
      els.compassStatus.textContent = "ok";
    } catch (e) {
      els.compassStatus.textContent = "blocked";
      setStatus("Compass/motion permission denied or unsupported.", "warn");
    }
  }

  function onDeviceOrientation(e) {
    // iOS provides webkitCompassHeading (0=North, CW positive)
    let heading;
    if (typeof e.webkitCompassHeading === 'number') {
      heading = e.webkitCompassHeading; // already degrees 0..360 (true-ish)
    } else if (typeof e.alpha === 'number') {
      // Android: alpha is device rotation around Z in degrees relative to some frame.
      // We'll treat it as compass-like; some devices need adjustment.
      // Best effort: alpha=0 facing north, increasing clockwise.
      heading = 360 - e.alpha; // invert to make CW positive
    }
    if (typeof heading === 'number' && !Number.isNaN(heading)) {
      if (emaHeading == null) emaHeading = heading;
      const diff = shortAngleDiff(heading, emaHeading);
      emaHeading = norm360(emaHeading + alpha * diff);
      myHeadingTrue = emaHeading;
      els.heading.textContent = `${myHeadingTrue.toFixed(0)}°`;
    }
    // Approximate pitch from beta (-180..180, front-back tilt). Normalize to [-90,90]
    if (typeof e.beta === 'number') {
      const pitch = clamp(e.beta, -90, 90);
      emaPitch = emaPitch + alpha * (pitch - emaPitch);
      myPitch = emaPitch;
    }
    updateArrowTransform();
  }

  // Geolocation
  function enableGeo() {
    if (!navigator.geolocation) {
      els.gpsStatus.textContent = "unsupported";
      setStatus("Geolocation unsupported.", "err");
      return;
    }
    els.gpsStatus.textContent = "requesting…";
    navigator.geolocation.watchPosition(pos => {
      myPos = { lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy };
      els.gpsStatus.textContent = "ok";
      els.latlon.textContent = `${myPos.lat.toFixed(5)}, ${myPos.lon.toFixed(5)}`;
      // fetch immediately on first lock
      scheduleFetch(100);
    }, err => {
      els.gpsStatus.textContent = "error";
      setStatus(`GPS error: ${err.message}`, "err");
    }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 15000 });
  }

  // OpenSky fetch
  let fetchTimer = null;
  function scheduleFetch(ms=8000) {
    clearTimeout(fetchTimer);
    fetchTimer = setTimeout(fetchNearestPlane, ms);
  }
  async function fetchNearestPlane() {
    if (!myPos) return scheduleFetch(2000);
    try {
      setStatus("Fetching aircraft…");
      // bounding box ~0.5° around you (≈55km latitude); widen if sparse
      const d = 0.5;
      const url = `https://opensky-network.org/api/states/all?lamin=${myPos.lat - d}&lomin=${myPos.lon - d}&lamax=${myPos.lat + d}&lomax=${myPos.lon + d}`;
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      const states = Array.isArray(data.states) ? data.states : [];

      // pick nearest plane with valid position
      let best = null;
      for (const s of states) {
        const callsign = (s[1] || "").trim() || "—";
        const lon = s[5], lat = s[6];
        const geo_alt = s[13]; // meters (may be null)
        if (lat == null || lon == null) continue;
        const ground_m = haversineMeters(myPos.lat, myPos.lon, lat, lon);
        // prefer planes with altitude (ignore very high alt for elevation calc fallback to 0)
        const alt_m = (geo_alt != null ? geo_alt : 0);
        const dist3d = Math.hypot(ground_m, alt_m);
        if (!best || dist3d < best.dist3d) {
          best = { lat, lon, alt_m, callsign, dist3d };
        }
      }
      if (!best) {
        setStatus("No aircraft nearby. Expanding search…", "warn");
        // widen box once
        scheduleFetch(4000);
        return;
      }
      const brg = initialBearing(myPos.lat, myPos.lon, best.lat, best.lon);
      const dist_m = haversineMeters(myPos.lat, myPos.lon, best.lat, best.lon);
      const el = elevationAngle_m(dist_m, best.alt_m);
      lastPlane = {
        ...best,
        brg, el, dist_m,
        time: (data.time || Date.now()/1000)
      };
      updateTargetReadout();
      updateArrowTransform();
      setStatus("Tracking nearest aircraft.");
    } catch (e) {
      setStatus("Aircraft fetch failed (CORS/rate limit?). Retrying…", "warn");
    } finally {
      scheduleFetch(8000);
    }
  }

  function updateTargetReadout() {
    if (!lastPlane) return;
    const alt_ft = metersToFeet(lastPlane.alt_m);
    els.targetCallsign.textContent = `Callsign: ${lastPlane.callsign}`;
    els.targetDist.textContent = `Dist: ${formatDist(lastPlane.dist_m)}`;
    els.targetAlt.textContent = `Alt: ${alt_ft ? Math.round(alt_ft).toLocaleString() + " ft" : "—"}`;
    els.targetBrg.textContent = `Bearing: ${lastPlane.brg.toFixed(0)}°`;
    els.targetEl.textContent = `Elev: ${lastPlane.el.toFixed(1)}°`;
    const ageSec = Math.max(0, Math.round(Date.now()/1000 - (lastPlane.time||Date.now()/1000)));
    els.updateAge.textContent = `Updated: ${ageSec}s ago`;
  }

  function updateArrowTransform() {
    if (!lastPlane || myHeadingTrue == null) return;
    // compute relative yaw (how far to turn phone horizontally) and relative pitch offset
    const yawDiff = shortAngleDiff(lastPlane.brg, myHeadingTrue); // degrees; +right (CW)
    const pitchTarget = lastPlane.el; // degrees up/down to target
    const pitchDiff = clamp(pitchTarget - myPitch, -90, 90);

    // Rotate arrow: yaw around Z (screen), then pitch around X to "tilt" towards elevation
    // We also add a slight 3D depth tilt for aesthetics.
    const transform = `rotateZ(${yawDiff}deg) rotateX(${ -pitchDiff }deg) translateZ(0)`;
    els.arrow.style.transform = transform;

    // Glow pulse stronger when roughly aligned
    const misalign = Math.hypot(yawDiff, pitchDiff);
    const intensity = clamp(1 - misalign / 45, 0, 1);
    els.arrow.style.filter = `drop-shadow(0 0 ${8 + 24*intensity}px rgba(112,184,255,${0.25+0.45*intensity}))`;
  }

  // Start button: request permissions and kick everything off
  els.startBtn.addEventListener('click', async () => {
    els.startBtn.disabled = true;
    setStatus("Requesting motion + location permissions…");

    await enableOrientation();
    enableGeo();
    scheduleFetch(1000);

    // keep screen awake if supported
    if ('wakeLock' in navigator) {
      try { await navigator.wakeLock.request('screen'); } catch {}
    }
    setStatus("Initializing sensors…");
  });

  // Visibility: refetch soon after returning to page
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) scheduleFetch(1000);
  });
})();
</script>
</body>
</html>
